[2017-12-11 19:15:52] local.INFO: lua_use_default_type -------------------- **语法:** *lua_use_default_type on | off*  **默认:** *lua_use_default_type on*  **环境:** *http, server, location, location if*  指定响应头中 Content-Type 的默认值，是否使用 default_type 指令中指明的 MIME 类型。 如果你的 Lua 请求处理程序不想要默认的 Content-Type 响应头，可以关闭这个指令。  默认情况下该指令被打开。  这个指令在 0.9.1 版本中首次引入。  [返回目录](#table-of-contents)  lua_malloc_trim --------------- **语法:** *lua_malloc_trim &lt;request-count&gt;*  **默认:** *lua_malloc_trim 1000*  **环境:** *http*  当 NGINX 核心每执行 `N` 次请求，告诉底层 `libc` 运行库，释放已缓存空闲内存还给操作系统。 `N` 的默认值是 1000。可以配置新的数值来控制 "请求数"，小的数字意味着更频繁的释放，这可能会引入比较高的 CPU 时间消耗和较少内存占用。 而大的数字通常则占用较少的 CPU 时间消耗和较大的内存占用。 所以这里需要根据自己的使用场景来调整。 <!-- Asks the underlying `libc` runtime library to release its cached free memory back to the operating system every `N` requests processed by the NGINX core. By default, `N` is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases. -->  配置参数为 `0` ，代表关闭周期性的内存整理。 <!-- Configuring the argument to `0` essentially turns off the periodical memory trimming altogether. -->  ```nginx   lua_malloc_trim 0;  # 完全关闭 trim ```  为了完成请求计数，目前是在 NGINX 的 log 阶段实现的。 当有子请求存在并且 `nginx.conf` 中出现 [log_subrequest on](http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest) 指令，可以能更快获得计数增长。 默认情况只统计“主请求”计数。 <!-- The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the [log_subrequest on](http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest) directives in `nginx.conf` may make the counting faster when subrequests are involved. By default, only "main requests" count. -->  注意：该指令 *不* 影响 LuaJIT 基于 `mmap` 系统调用的内存分配。  该指令在 `v0.10.7` 版本首次引入。  [返回目录](#directives)  lua_code_cache -------------- **语法:** *lua_code_cache on | off*  **默认:** *lua_code_cache on*  **环境:** *http, server, location, location if*  打开或者关闭 *_by_lua_file 指令（类似 set_by_lua_file 和 content_by_lua_file） 中指定的 Lua 代码，以及 Lua 模块的 Lua 代码缓存。  当缓存关闭时，每个 ngx_lua 处理的请求都将会运行在一个单独的 Lua 虚拟机实例中，从 0.9.3 版本开始。 所以在 set_by_lua_file, content_by_lua_file, access_by_lua_file 中引用的 Lua 文件不会被缓存， 并且所有使用的 Lua 模块都会从头开始加载。有了这个选项，开发者很容易通过编辑文件并重新请求的方法进行测试。  然而需要注意的是，当你编辑写在 nginx.conf 中内嵌的 Lua 代码时， 比如通过 set_by_lua, content_by_lua, access_by_lua, rewrite_by_lua 这些指令 写在 nginx.conf 里面的 Lua 代码，缓存不会被更新。 因为只有 Nginx 的配置文件解释器才能正确解析 nginx.conf， 所以重新加载配置文件的唯一办法是发送 HUP 信号或者重启 Nginx。  ```shell kill -HUP pid nginx -s reload ```  即使代码缓存打开了，在 *_by_lua_file 中使用 dofile 或 loadfile 函数时内容不会被缓存（除非你自己缓存结果）。 通常你可以在 init_by_lua 或 init_by_lua_file 指令中加载所有这些文件， 或者让这些 Lua 文件变成真正的 Lua 模块，通过 require 来加载。  现在 ngx_lua 模块还不支持 Apache mod_lua 模块中可用的 stat 模式（已经列入待做任务）。  不推荐在生产环境中关闭 lua 代码缓存，请确保它只在开发环境中使用，他对整体性能有非常明显的影响。 举个例子，输出“你好世界”在没有开启 lua 代码缓存时可以降低一个量级。  [返回目录](#directives)  lua_regex_cache_max_entries --------------------------- **语法:** *lua_regex_cache_max_entries &lt;num&gt;*  **默认:** *lua_regex_cache_max_entries 1024*  **环境:** *http*  在工作进程级别，指定正则表达式编译缓存允许的最大数目。  正则表达式被用于 [ngx.re.match](#ngxrematch)， [ngx.re.gmatch](#ngxregmatch)， [ngx.re.sub](#ngxresub)， 和 [ngx.re.gsub](#ngxregsub)，如果使用`o` (既，编译一次的标识)正则选项，将会被缓存。  允许的默认数量为 1024，当达到此限制，新的正则表达式将不会被缓存（就像没指定`o`选项一样），将会有且仅只有一个告警信息在 `error.log` 文件中：      2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...  如果你是通过加载 `resty.core.regex` 模块（或者仅仅是 `resty.core` 模块）来使用 [lua-resty-core](https://github.com/openresty/lua-resty-core) 实现的 `ngx.re.*`， 一个基于 LRU 的缓存将被用到这里的正则表达式缓存。  <!-- If you are using the `ngx.re.*` implementation of [lua-resty-core](https://github.com/openresty/lua-resty-core) by loading the `resty.core.regex` module (or just the `resty.core` module), then an LRU cache is used for the regex cache being used here. -->  对于部分正则表达式（字符串的各种替换，如 [ngx.re.sub](#ngxresub) 和 [ngx.re.gsub](#ngxregsub)），不要使用 `o`选项，这类正则每次都不一样，缓存无法被利用。这样我们可以避免撞上最大数的限制。  [返回目录](#directives)  lua_regex_match_limit --------------------- **语法:** *lua_regex_match_limit &lt;num&gt;*  **默认:** *lua_regex_match_limit 0*  **环境:** *http*  指定执行 [ngx.re API](#ngxrematch) 时使用 PCRE 库的"匹配限制"。引述 PCRE 手册，“the limit ... has the effect of limiting the amount of backtracking that can take place”。  当触发了这个限制，在 Lua 代码的 [ngx.re API](#ngxrematch) 函数，将返回错误信息 "pcre_exec() failed: -8"。  当设置了限制为 0，将使用编译 PCRE 库的默认 "match limit"。这也是这个配置的默认值。  这个指令是在`v0.8.5`发行版被首次引入的。  [返回目录](#directives)  lua_package_path ----------------  **语法:** *lua_package_path &lt;lua-style-path-str&gt;*  **默认:** *当前环境 LUA_PATH 的环境变量或编译指定的默认值*  **环境:** *http*  设置 [set_by_lua*](#set_by_lua)，[content_by_lua*](#content_by_lua) 和 其他脚本对 Lua 模块的查找路径。路径字符串是标准 Lua 路径格式，特殊标识 `;;` 可被用来代表原始搜索路径。  从`v0.5.0rc29`发行版开始，特殊符号`$prefix` 或 `${prefix}`可用于搜索路径字符串中。`server prefix`的值，通常是由 Nginx 服务启动时的`-p PATH`命令行决定的。  [返回目录](#directives)  lua_package_cpath -----------------  **语法:** *lua_package_cpath &lt;lua-style-cpath-str&gt;*  **默认:** *当前环境 LUA_CPATH 的环境变量或编译指定的默认值*  **环境:** *http*  设置 [set_by_lua*](#set_by_lua)，[content_by_lua*](#content_by_lua) 和其他脚本对 Lua C 模块的查找路径。 cpath 路径字符串是标准 Luacpath 路径格式，特殊标识`;;` 可被用来代表原始 cpath 路径。  从`v0.5.0rc29`发行版开始，特殊符号`$prefix` 或 `${prefix}`可用于搜索路径字符串中。`server prefix`的值，通常是由 Nginx 服务启动时的`-p PATH`命令行决定的。  [返回目录](#directives)  init_by_lua -----------  **语法:** *init_by_lua &lt;lua-script-str&gt;*  **环境:** *http*  **阶段:** *loading-config*  **注意** 自从 `v0.9.17` 版本, 不鼓励使用该指令，应使用新的 [init_by_lua_block](#init_by_lua_block) 指令进行替代。  当 Nginx master 进程（如果有）加载 Nginx 配置文件时，在全局的 Lua 虚拟机上运行 `<lua-script-str>` 指定的 Lua 代码。  当 Nginx 收到`HUP`信号并开始重新加载配置文件，Lua 虚拟机将重新创建并且`init_by_lua`在新的 Lua 虚拟机中再次执行。为防止[lua_code_cache](#lua_code_cache)指令是关闭的（默认打开），对于这个场景`init_by_lua`将在每个请求之上运行，因为在这个场景中，每个请求都会创建新的 Lua 虚拟机，他们都是独立存在。  通常，你可以在服务启动时注册 Lua 全局变量或预加载 Lua 模块。这是个预加载Lua模块的示例代码：  ```nginx   init_by_lua 'cjson = require "cjson"';   server {      location = /api {          content_by_lua_block {              ngx.say(cjson.encode({dog = 5, cat = 6}))          }      }  } ```  你也可以在这个阶段初始化[lua_shared_dict](#lua_shared_dict)共享内存内容。这里是示例代码：  ```nginx   lua_shared_dict dogs 1m;   init_by_lua '      local dogs = ngx.shared.dogs;      dogs:set("Tom", 56)  ';   server {      location = /api {          content_by_lua_block {              local dogs = ngx.shared.dogs;              ngx.say(dogs:get("Tom"))          }      }  } ```  需要注意，当配置重载（例如`HUP`信号）时 [lua_shared_dict](#lua_shared_dict)的共享数据是不会被清空的。这种情况下，如果你不想在`init_by_lua`再次初始化你的共享数据，你需要设置一个个性标识并且在你的`init_by_lua`代码中每次都做检查。  因为在这个上下文中的Lua代码是在 Nginx fork 工作进程之前（如果有）执行，加载的数据和代码将被友好 [Copy-on-write (COW)](http://en.wikipedia.org/wiki/Copy-on-write) 特性提供给其他所有工作进程，从而节省了大量内存。  不要在这个上下文中初始化你自己的 Lua 全局变量，因为全局变量的使用有性能损失并会带来全局命名污染（可以查看 [Lua 变量范围](#lua-variable-scope)获取更多细节）。推荐的方式是正确使用 [Lua模块](http://www.lua.org/manual/5.1/manual.html#5.3) 文件（不要使用标准 Lua 函数 [module()](http://www.lua.org/manual/5.1/manual.html#pdf-module)来定义 Lua 模块，因为它同样对全局命名空间有污染），在`init_by_lua` 或 其他上下文中调用 [require()](http://www.lua.org/manual/5.1/manual.html#pdf-require) 来加载你自己的模块文件。[require()](http://www.lua.org/manual/5.1/manual.html#pdf-require) 会在全局 Lua 注册的`package.loaded`表中缓存 Lua 模块，所以在整个 Lua 虚拟机实例中你的模块将只会加载一次。  在这个上下文中，只有一小部分的 [Nginx Lua API](#nginx-api-for-lua) 是被支持的：   * 记录日志的 APIs：[ngx.log](#ngxlog) 和 [print](#print) * 共享内存字典 APIs：[ngx.shared.DICT](#ngxshareddict)  在这个上下文中，根据用户的后续需要，将会支持更多的 Nginx Lua APIs。  基本上，在这个上下文中，你可以保守使用 Lua 库完成阻塞 I/O 调用，因为在 master 进程的阻塞调用在服务的启动过程中是完全没问题的。进一步说在配置加载阶段，Nginx 核心就是阻塞 I/O 方式处理的（至少在解析上游主机名称时）。  你应该非常小心，在这种情况下注册的 Lua 代码潜在的安全漏洞，因为 Nginx 的主进程经常是'root`帐户下运行。  这个指令是 `v0.5.5` 版本中第一次引入的。  [返回目录](#directives)  init_by_lua_block -----------------  **语法:** *init_by_lua_block { lua-script }*  **环境:** *http*  **阶段:** *loading-config*  与 [init_by_lua](#init_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   init_by_lua_block {      print("I need no extra escaping here, for example: \r\nblah")  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  init_by_lua_file ----------------  **语法:** *init_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http*  **阶段:** *loading-config*  与 [init_by_lua](#init_by_lua) 等价，通过`<path-to-lua-script-file>`指定文件的 Lua 代码 或 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support)来执行。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  该指令在`v0.5.5`发行版第一次被引入。  [返回目录](#directives)  init_worker_by_lua ------------------  **语法:** *init_worker_by_lua &lt;lua-script-str&gt;*  **环境:** *http*  **阶段:** *starting-worker*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [init_worker_by_lua_block](#init_worker_by_lua_block) 指令进行替代。  开启 master 进程模式，Nginx 工作进程启动时执行指定的 Lua 代码。关闭 master 模式，将在 [init_by_lua*](#init_by_lua) 后直接运行。  这个指令经常被用来创建单进程的反复执行定时器（通过 [ngx.timer.at](#ngxtimerat) Lua API 创建），可以是后端服务健康检查，也可以是其他定时的日常工作。下面是个例子：  ```nginx   init_worker_by_lua '      local delay = 3  -- in seconds      local new_timer = ngx.timer.at      local log = ngx.log      local ERR = ngx.ERR      local check       check = function(premature)          if not premature then              -- do the health check or other routine work              local ok, err = new_timer(delay, check)              if not ok then                  log(ERR, "failed to create timer: ", err)                  return              end          end      end       local ok, err = new_timer(delay, check)      if not ok then          log(ERR, "failed to create timer: ", err)          return      end  '; ```  这个指令是在`v0.9.5`发行版第一次引入。  [返回目录](#directives)  init_worker_by_lua_block ------------------------  **语法:** *init_worker_by_lua_block { lua-script }*  **环境:** *http*  **阶段:** *starting-worker*  与 [init_worker_by_lua](#init_worker_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   init_worker_by_lua_block {      print("I need no extra escaping here, for example: \r\nblah")  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  init_worker_by_lua_file -----------------------  **语法:** *init_worker_by_lua_file &lt;lua-file-path&gt;*  **环境:** *http*  **阶段:** *starting-worker*  与 [init_worker_by_lua](#init_worker_by_lua)等价，通过`<lua-file-path>`指定的 Lua 或 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 文件来执行。  该指令是在`v0.9.5`发行版第一次引入。  [返回目录](#directives)  set_by_lua ----------  **语法:** *set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]*  **环境:** *server, server if, location, location if*  **阶段:** *rewrite*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [set_by_lua_block](#set_by_lua_block) 指令进行替代。  使用可选的输入参数`$arg1 $arg2 ...`，执行指定的代码`<lua-script-str>`，并返回字符串结果到`$res`。  `<lua-script-str>`的代码可以做 [API 调用](#nginx-api-for-lua)，并能从`ngx.arg`表中获取输入参数（下标起始值是`1`并顺序增长）。  该指令被设计为执行短小、快速的代码块，因为代码执行时Nginx的事件循环是被阻塞的。因此应避免耗时的代码处理。  这个指令是通过挂载自定义命令到标准 [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html) 模块列表来实现。因为模块 [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html) 中是不支持非阻塞 I/O，所以在本指令中，是无法 yield 当前 Lua 的“轻线程”。  在`set_by_lua`的上下文中，至少下列 API 函数目前是被禁止的：  * 输出 API 函数 (例如 [ngx.say](#ngxsay) 和 [ngx.send_headers](#ngxsend_headers)) * 控制 API 函数 (例如 [ngx.exit](#ngxexit)) * 子请求 API 函数 (例如 [ngx.location.capture](#ngxlocationcapture) 和 [ngx.location.capture_multi](#ngxlocationcapture_multi)) * Cosocket API 函数 (例如 [ngx.socket.tcp](#ngxsockettcp) 和 [ngx.req.socket](#ngxreqsocket)) * 休眠 API 函数 [ngx.sleep](#ngxsleep)  额外注意的，本指令一次只能写回一个值到一个 Nginx 变量。尽管如此，可以使用 [ngx.var.VARIABLE](#ngxvarvariable) 接口绕过这个限制。  ```nginx   location /foo {      set $diff ''; # we have to predefine the $diff variable here       set_by_lua $sum '          local a = 32          local b = 56           ngx.var.diff = a - b;  -- write to $diff directly          return a + b;          -- return the $sum value normally      ';       echo "sum = $sum, diff = $diff";  } ```  这个指令可以自由的与其他指令模块混合使用，如 [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html), [set-misc-nginx-module](http://github.com/openresty/set-misc-nginx-module) 和 [array-var-nginx-module](http://github.com/openresty/array-var-nginx-module)。所有这些指令的执行顺序，将和他们配置文件中出现的顺序一致。   ```nginx   set $foo 32;  set_by_lua $bar 'return tonumber(ngx.var.foo) + 1';  set $baz "bar: $bar";  # $baz == "bar: 33" ```  自 `v0.5.0rc29` 版本开始，本指令的 `<lua-script-str>` 参数中不再支持内联 Nginx 变量，所以可以直接使用 $ 字符作为其字面值。  这个指令需要 [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) 模块。  [返回目录](#directives)  set_by_lua_block ----------------  **语法:** *set_by_lua_block $res { lua-script }*  **环境:** *server, server if, location, location if*  **阶段:** *rewrite*  与 [set_by_lua*](#set_by_lua) 指令相似，以下情况除外：  1. 该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义） 1. 该指令和 [set_by_lua*](#set_by_lua) 一样，在 Lua 脚本的后面不支持额外参数  例如：  ```nginx   set_by_lua_block $res { return 32 + math.cos(32) }  # $res now has the value "32.834223360507" or alike. ```  在 Lua 代码块中无需任何的特殊转义。  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  set_by_lua_file --------------- **语法:** *set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]*  **环境:** *server, server if, location, location if*  **阶段:** *rewrite*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [set_by_lua*](#set_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  对于该指令，对`<path-to-lua-script-file>`的字符串参数支持内联 Nginx 变量。但必须要额外注意注入攻击。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  当 Lua 代码缓存开启（默认），用户代码在第一次请求时完成加载（只有一次）并缓存，当 Lua 文件被修改时，每次都要对 Nginx 配置进行重新加载。Lua 代码缓存是可以暂时被禁用，通过开关 [lua_code_cache](#lua_code_cache) 在`nginx.conf`中设置为`off`，这样就可以避免反复重新加载 Nginx。  该指令需要 [ngx_devel_kit](https://github.com/simpl/ngx_devel_kit) 模块。  [返回目录](#directives)  content_by_lua --------------  **语法：** *content_by_lua &lt;lua-script-str&gt;*  **环境：** *location, location if*  **阶段：** *content*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [content_by_lua_block](#content_by_lua_block) 指令进行替代。  作为"内容处理程序"，为每一个请求执行`<lua-script-str>`中指定的Lua代码。  这些 Lua 代码可以调用 [全部 API](#nginx-api-for-lua)，并作为一个新的协程，在一个独立的全局环境中执行（就像一个沙盒）。  不要将本指令和其他内容处理程序指令放到同一个 location 中。 比如，本指令和 [proxy_pass](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass) 指令就不能在同一个 location 中使用。  [返回目录](#directives)  content_by_lua_block --------------------  **语法:** *content_by_lua_block { lua-script }*  **环境:** *location, location if*  **阶段:** *content*  与 [content_by_lua](#content_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   content_by_lua_block {      ngx.say("I need no extra escaping here, for example: \r\nblah")  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  content_by_lua_file -------------------  **语法:** *content_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *location, location if*  **阶段:** *content*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [content_by_lua](#content_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  在`<path-to-lua-script-file>`中可以使用 Nginx 的内置变量来提高灵活性，然而这带有一定的风险，通常并不推荐使用。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  当 Lua 代码缓存开启（默认），用户代码在第一次请求时完成加载（只有一次）并缓存，当 Lua 文件被修改时，每次都要对 Nginx 配置进行重新加载。Lua 代码缓存是可以暂时被禁用，通过开关 [lua_code_cache](#lua_code_cache) 在`nginx.conf`中设置为`off`，这样就可以避免反复重新加载 Nginx。  支持通过 Nginx 变量完成动态调度文件路径，例如：  ```nginx   # 注意: nginx 变量必须要小心过滤，否则它将带来严重的安全风险！  location ~ ^/app/([-_a-zA-Z0-9/]+) {      set $path $1;      content_by_lua_file /path/to/lua/app/root/$path.lua;  } ```  一定要非常小心恶意用户的输入，并始终仔细验证或过滤掉用户提供的路径项。  [返回目录](#directives)  rewrite_by_lua --------------  **语法:** *rewrite_by_lua &lt;lua-script-str&gt;*  **环境:** *http, server, location, location if*  **阶段:** *rewrite tail*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [rewrite_by_lua_block](#rewrite_by_lua_block) 指令进行替代。  作为一个重写阶段的处理程序，为每个请求执行由`<lua-script-str>`指定的 Lua 代码。  这些 Lua 代码可以调用 [全部 API](#nginx-api-for-lua)，并作为一个新的协程，在一个独立的全局环境中执行（就像一个沙盒）。  注意这个处理过程总是在标准 [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html) 的 *后* 面。所以下面的示例可以按照预期执行：  ```nginx   location /foo {      set $a 12; # create and initialize $a      set $b ""; # create and initialize $b      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';      echo "res = $b";  } ```  因为 `set $a 12` 和 `set $b ""` 的执行都在 [rewrite_by_lua](#rewrite_by_lua) 的前面。  另一方面，下面的示例是不能按照预期执行：  ```nginx   ?  location /foo {  ?      set $a 12; # create and initialize $a  ?      set $b ''; # create and initialize $b  ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';  ?      if ($b = '13') {  ?         rewrite ^ /bar redirect;  ?         break;  ?      }  ?  ?      echo "res = $b";  ?  } ```  因为 `if` 是 [rewrite_by_lua](#rewrite_by_lua) 之 *前* 执行的，尽管在配置中它被放到 [rewrite_by_lua](#rewrite_by_lua) 后面。  正确的处理方式应该是这样：  ```nginx   location /foo {      set $a 12; # create and initialize $a      set $b ''; # create and initialize $b      rewrite_by_lua '          ngx.var.b = tonumber(ngx.var.a) + 1          if tonumber(ngx.var.b) == 13 then              return ngx.redirect("/bar");          end      ';       echo "res = $b";  } ```  注意，[ngx_eval](http://www.grid.net.ru/nginx/eval.en.html) 模块可以近似的使用 [rewrite_by_lua](#rewrite_by_lua)。例如：  ```nginx   location / {      eval $res {          proxy_pass http://foo.com/check-spam;      }       if ($res = 'spam') {          rewrite ^ /terms-of-use.html redirect;      }       fastcgi_pass ...;  } ```  在 ngx_lua 中可以这样实施：  ```nginx   location = /check-spam {      internal;      proxy_pass http://foo.com/check-spam;  }   location / {      rewrite_by_lua '          local res = ngx.location.capture("/check-spam")          if res.body == "spam" then              return ngx.redirect("/terms-of-use.html")          end      ';       fastcgi_pass ...;  } ```  如同其他重写阶段处理，[rewrite_by_lua](#rewrite_by_lua) 在子请求中也执行的。  注意，在 [rewrite_by_lua](#rewrite_by_lua) 处理内部，当调用`ngx.exit(ngx.OK)`时，nginx 请求将继续下一阶段的内容处理。要在 [rewrite_by_lua](#rewrite_by_lua)处理中终结当前请求，调用 [ngx.exit](#ngxexit)，成功的请求设定 status >= 200 (`ngx.HTTP_OK`) 并 status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`)，失败的请求设定`ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (或其他相关的)。  如果使用了 [ngx_http_rewrite_module](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html) 的 [rewrite](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite) 指令来改变 URI 并发起内部重定向，那么在当前 location 内任何有序的 [rewrite_by_lua](#rewrite_by_lua) 或 [rewrite_by_lua_file](#rewrite_by_lua_file) 代码都将不被执行。例如：  ```nginx   location /foo {      rewrite ^ /bar;      rewrite_by_lua 'ngx.exit(503)';  }  location /bar {      ...  } ```  如果 `rewrite ^ /bar last` 被用做一个类似内部重定向使用，它将被忽略，这里的 Lua 代码 `ngx.exit(503)` 是永远不能执行的。如果使用了 `break` 标识，这里将没有内部重定向，并且执行 `rewrite_by_lua` 中的 Lua 代码。  `rewrite_by_lua`代码将永远在 `rewrite` 请求处理阶段后面，除非 [rewrite_by_lua_no_postpone](#rewrite_by_lua_no_postpone) 配置开启。  [返回目录](#directives)  rewrite_by_lua_block --------------------  **语法:** *rewrite_by_lua_block { lua-script }*  **环境:** *http, server, location, location if*  **阶段:** *rewrite tail*  与 [rewrite_by_lua](#rewrite_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   rewrite_by_lua_block {      do_something("hello, world!\nhiya\n")  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  rewrite_by_lua_file -------------------  **语法:** *rewrite_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http, server, location, location if*  **阶段:** *rewrite tail*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [rewrite_by_lua](#rewrite_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  在`<path-to-lua-script-file>`中可以使用 Nginx 的内置变量用来提高灵活性，然而这带有一定的风险，通常并不推荐使用。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  当 Lua 代码缓存开启（默认），用户代码在第一次请求时完成加载（只有一次）并缓存，当 Lua 文件被修改时，每次都要对 Nginx 配置进行重新加载。Lua 代码缓存是可以暂时被禁用，通过开关 [lua_code_cache](#lua_code_cache) 在`nginx.conf`中设置为`off`，这样就可以避免反复重新加载 Nginx。  `rewrite_by_lua_file`代码将永远在 `rewrite` 请求处理阶段后面，除非 [rewrite_by_lua_no_postpone](#rewrite_by_lua_no_postpone) 配置开启。  支持通过 Nginx 变量完成动态调度文件路径，就像 [content_by_lua_file](#content_by_lua_file) 一样。  [返回目录](#directives)  access_by_lua -------------  **语法:** *access_by_lua &lt;lua-script-str&gt;*  **环境:** *http, server, location, location if*  **阶段:** *access tail*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [access_by_lua_block](#access_by_lua_block) 指令进行替代。  扮演 access 阶段处理，对每次请求执行在`<lua-script-str>`中指名的 Lua 代码。  这些 Lua 代码可以调用 [全部 API](#nginx-api-for-lua)，并作为一个新的协程，在一个独立的全局环境中执行（就像一个沙盒）。  注意：本指令的处理总是在标准 [ngx_http_access_module](http://nginx.org/en/docs/http/ngx_http_access_module.html) 的 *后* 面。所以下面的示例可以按照预期工作：  ```nginx   location / {      deny    192.168.1.1;      allow   192.168.1.0/24;      allow   10.1.1.0/16;      deny    all;       access_by_lua '          local res = ngx.location.capture("/mysql", { ... })          ...      ';       # proxy_pass/fastcgi_pass/...  } ```  换句话说，如果一个客户端 IP 地址在黑名单中，它将在 [access_by_lua](#access_by_lua) 中的 Mysql 复杂认证请求之前被拒绝。  注意，[ngx_auth_request](http://mdounin.ru/hg/ngx_http_auth_request_module/) 模块可以近似的被 [access_by_lua](#access_by_lua) 实现：  ```nginx   location / {      auth_request /auth;       # proxy_pass/fastcgi_pass/postgres_pass/...  } ```  使用 ngx_lua 是这样：  ```nginx   location / {      access_by_lua '          local res = ngx.location.capture("/auth")           if res.status == ngx.HTTP_OK then              return          end           if res.status == ngx.HTTP_FORBIDDEN then              ngx.exit(res.status)          end           ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)      ';       # proxy_pass/fastcgi_pass/postgres_pass/...  } ```  和其他 access 阶段处理实现一样，[access_by_lua](#access_by_lua) 将 *不* 能运行在子请求中。  注意，在 [access_by_lua](#access_by_lua) 处理内部，当调用`ngx.exit(ngx.OK)`时，nginx 请求将继续下一阶段的内容处理。要在 [access_by_lua](#access_by_lua) 处理中终结当前请求，调用 [ngx.exit](#ngxexit)，成功的请求设定 status >= 200 (`ngx.HTTP_OK`) 并 status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`)，失败的请求设定`ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (或其他相关的)。  从 `v0.9.20` 版本开始，你可以使用 [access_by_lua_no_postpone](#access_by_lua_no_postpone) 指令来控制该 handler 在 Nginx 的 "access" 请求处理中的执行时机。  [返回目录](#directives)  access_by_lua_block -------------------  **语法:** *access_by_lua_block { lua-script }*  **环境:** *http, server, location, location if*  **阶段:** *access tail*  与 [access_by_lua](#access_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  For instance,  ```nginx   access_by_lua_block {      do_something("hello, world!\nhiya\n")  } ```  该指令在 `v0.9.17` 版本首次引入。  access_by_lua_file ------------------  **语法:** *access_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http, server, location, location if*  **阶段:** *access tail*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [access_by_lua](#access_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  在`<path-to-lua-script-file>`中可以使用 Nginx 的内置变量用来提高灵活性，然而这带有一定的风险，通常并不推荐使用。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  当 Lua 代码缓存开启（默认），用户代码在第一次请求时完成加载（只有一次）并缓存，当 Lua 文件被修改时，每次都要对 Nginx 配置进行重新加载。Lua 代码缓存是可以暂时被禁用，通过开关 [lua_code_cache](#lua_code_cache) 在`nginx.conf`中设置为`off`，这样就可以避免反复重新加载 Nginx。  支持通过 Nginx 变量完成动态调度文件路径，就像 [content_by_lua_file](#content_by_lua_file) 一样。  [返回目录](#directives)  header_filter_by_lua --------------------  **语法：** *header_filter_by_lua &lt;lua-script-str&gt;*  **环境：** *http, server, location, location if*  **阶段：** *output-header-filter*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [header_filter_by_lua_block](#header_filter_by_lua_block) 指令进行替代。  用`<lua-script-str>`中指名的lua代码，来完成应答消息头部的过滤。  注意，下列的接口函数在这个执行阶段是被禁用的：  - 输出类函数（例：ngx.say 和 ngx.send_headers）  - 控制类函数（例：ngx.redirect 和 ngx.exec）  - 子请求相关函数（例：ngx.location.capture和ngx.location.capture_multi）  - cosocket 类函数（例：ngx.socket.tcp 和 ngx.req.socket）  这里有个使用 Lua 过滤完成覆盖应答头的例子（如果没有则添加）：  ```nginx   location / {      proxy_pass http://mybackend;      header_filter_by_lua 'ngx.header.Foo = "blah"';  }  ```  该指令在版本 `v0.2.1rc20` 中第一次引入。  [返回目录](#directives)  header_filter_by_lua_block --------------------------  **语法:** *header_filter_by_lua_block { lua-script }*  **环境:** *http, server, location, location if*  **阶段:** *output-header-filter*  与 [header_filter_by_lua](#header_filter_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   header_filter_by_lua_block {      ngx.header["content-length"] = nil  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  header_filter_by_lua_file -------------------------  **语法:** *header_filter_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http, server, location, location if*  **阶段:** *output-header-filter*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [header_filter_by_lua](#header_filter_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  该指令是在`v0.2.1rc20`版本第一次引入。  [返回目录](#directives)  body_filter_by_lua ------------------  **语法:** *body_filter_by_lua &lt;lua-script-str&gt;*  **环境:** *http, server, location, location if*  **阶段:** *output-body-filter*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [body_filter_by_lua_block](#body_filter_by_lua_block) 指令进行替代。  使用`<lua-script-str>`指定的 Lua 代码定义一个输出应答体过滤器。  输入数据块是 [ngx.arg](#ngxarg)\[1\]（Lua的字符串形式）,结束标识"eof"是应答体数据最后一位[ngx.arg](#ngxarg)\[2\]（Lua的布尔值形式）。  在这个场景下，结束标识"eof"仅仅是 Nginx chain 缓冲区的`last_buf`（主请求）或`last_in_chain`（子请求）。（在`v0.7.14`版本之前，结束标识"eof"在子请求中是完全不能使用的。）  使用下面 Lua 代码，可以对输出数据流立即终止：  ```lua   return ngx.ERROR ```  这样截断响应体，通常导致结果不完整的，也是无效的响应。  本指令的 Lua 代码可以使用 Lua 字符串或字符串的表重写 [ngx.arg](#ngxarg)\[1\] 输入数据块内容，从而完成 Nginx 输出体下游过滤数据修改。例如，在输出体转换所有的小写字母，我们可以这样用：  ```nginx   location / {      proxy_pass http://mybackend;      body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';  } ```  当设置`nil`或一个空的 Lua 字符串值给`ngx.arg[1]`，将没有任何数据块下发到 Nginx 下游。  同样，新的结束标识"eof"也可以通过对 [ngx.arg](#ngxarg)\[2\] 设定一个布尔值。例如：  ```nginx   location /t {      echo hello world;      echo hiya globe;       body_filter_by_lua '          local chunk = ngx.arg[1]          if string.match(chunk, "hello") then              ngx.arg[2] = true  -- new eof              return          end           -- just throw away any remaining chunk data          ngx.arg[1] = nil      ';  } ```  然后 `GET /t` 将返回下面的结果：      hello world  就是说，当应答体过滤发现一个块包含关键字 "hello"，它将立即设置结束标识"eof"为 true ，应答内容被截断尽管后面还有有效数据。  当Lua代码可能改变应答体的长度时，我们必须总是清空响应头中的`Content-Length`（如果有），强制使用流式输出，如：  ```nginx   location /foo {      # fastcgi_pass/proxy_pass/...       header_filter_by_lua_block { ngx.header.content_length = nil }      body_filter_by_lua_block { ngx.arg[1] = string.len(ngx.arg[1]) .. "\\n" };  } ```  注意：下面这些 API 函数在这个环境中是禁用的，这受制于当前 Nginx 输出过滤器的实现：  * 输出 API 函数类（例如：[ngx.say](#ngxsay) 和 [ngx.send_headers](#ngxsend_headers)） * 控制 API 函数类（例如：[ngx.redirect](#ngxredirect) 和 [ngx.exec](#ngxexec)） * 子请求函数类（例如：[ngx.location.capture](#ngxlocationcapture) 和 [ngx.location.capture_multi](#ngxlocationcapture_multi)） * cosocket 函数类（例如：[ngx.socket.tcp](#ngxsockettcp) 和 [ngx.req.socket](#ngxreqsocket)）  Nginx 输出过滤器在一个单独请求中可能被调用多次，因为应答体可能使用块的方式进行投递。所以，本指令中的 Lua 代码在这个单独的 HTTP 请求生命周期内，同样会执行多次。  该指令在`v0.5.0rc32`版本中首次引入。  [返回目录](#directives)  body_filter_by_lua_block ------------------------  **语法:** *body_filter_by_lua_block { lua-script-str }*  **环境:** *http, server, location, location if*  **阶段:** *output-body-filter*  与 [body_filter_by_lua*](#body_filter_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   body_filter_by_lua_block {      local data, eof = ngx.arg[1], ngx.arg[2]  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  body_filter_by_lua_file -----------------------  **语法:** *body_filter_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http, server, location, location if*  **阶段:** *output-body-filter*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [body_filter_by_lua*](#body_filter_by_lua) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  该指令是在`v0.5.0rc32`版本第一次引入。  [返回目录](#directives)  log_by_lua ----------  **语法:** *log_by_lua &lt;lua-script-str&gt;*  **环境:** *http, server, location, location if*  **阶段:** *log*  **注意** 自从 `v0.9.17` 版本, 使用该指令是 *不优雅* 的，应使用新的 [log_by_lua_block](#log_by_lua_block) 指令进行替代。  在 `log` 请求处理阶段执行内嵌在`<lua-script-str>`的 Lua 代码。它不替代当前access的日志，而是在其前面执行。  注意，当前环境中以下 API 函数当前是被禁用的：  * 输出API函数类（例如：[ngx.say](#ngxsay) 和 [ngx.send_headers](#ngxsend_headers)） * 控制API函数类（例如：[ngx.exit](#ngxexit) 和 [ngx.exec](#ngxexec)） * 子请求函数类（例如：[ngx.location.capture](#ngxlocationcapture) 和 [ngx.location.capture_multi](#ngxlocationcapture_multi)） * cosocket 函数类（例如：[ngx.socket.tcp](#ngxsockettcp) 和 [ngx.req.socket](#ngxreqsocket)）  这是一个收集 [$upstream_response_time](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time) 平均处理的例子：  ```nginx   lua_shared_dict log_dict 5M;   server {      location / {          proxy_pass http://mybackend;           log_by_lua '              local log_dict = ngx.shared.log_dict              local upstream_time = tonumber(ngx.var.upstream_response_time)               local sum = log_dict:get("upstream_time-sum") or 0              sum = sum + upstream_time              log_dict:set("upstream_time-sum", sum)               local newval, err = log_dict:incr("upstream_time-nb", 1)              if not newval and err == "not found" then                  log_dict:add("upstream_time-nb", 0)                  log_dict:incr("upstream_time-nb", 1)              end          ';      }       location = /status {          content_by_lua_block {              local log_dict = ngx.shared.log_dict              local sum = log_dict:get("upstream_time-sum")              local nb = log_dict:get("upstream_time-nb")               if nb and sum then                  ngx.say("average upstream response time: ", sum / nb,                          " (", nb, " reqs)")              else                  ngx.say("no data yet")              end          }      }  } ```  该指令在`v0.5.0rc31`版本被首次引入。  [返回目录](#directives)  log_by_lua_block ----------------  **语法:** *log_by_lua_block { lua-script }*  **内容:** *http, server, location, location if*  **阶段:** *log*  与 [log_by_lua](#log_by_lua) 指令相似，只不过该指令在一对括号（`{}`）中直接内嵌 Lua 代码，替代之前 Nginx 的字符串（需要特殊字符转义）。  例如：  ```nginx   log_by_lua_block {      print("I need no extra escaping here, for example: \r\nblah")  } ```  该指令在 `v0.9.17` 版本首次引入。  [返回目录](#directives)  log_by_lua_file ---------------  **语法:** *log_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http, server, location, location if*  **阶段:** *log*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与[log_by_lua](#log_by_lua)是等价的，该指令从`v0.5.0rc32`开始支持[Lua/LuaJIT 字节码](#lualuajit-bytecode-support)的执行。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  该指令是在`v0.5.0rc31`版本第一次引入。  [返回目录](#directives)  balancer_by_lua_block ---------------------  **语法:** *balancer_by_lua_block { lua-script }*  **环境:** *upstream*  **阶段:** *content*  该指令执行上游的负载均衡 Lua 代码（任何上游实体），代码配置在 `upstream {}` 小节中。  举例：  ```nginx   upstream foo {      server 127.0.0.1;      balancer_by_lua_block {          -- 使用 Lua 作为一个动态均衡器完成一些有趣的事情      }  }   server {      location / {          proxy_pass http://foo;      }  } ```  Lua 的负载均衡可以和任何已经存在的 nginx 上游模块一起工作，例如：[ngx_proxy](http://nginx.org/en/docs/http/ngx_http_proxy_module.html) 和 [ngx_fastcgi](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html)。  同样， Lua 负载均衡可以和标准的上游连接池机制一起工作，例如标准的 [keepalive](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive) 指令。只要确保在单个`upstream {}` 配置小节中 [keepalive](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive) 指令要放在 `balancer_by_lua_block` 小节的 *后* 面。  Lua 负载均衡能完全忽略配置在 `upstream {}` 小节中定义的服务列表，并且从一个完全动态的服务列表中挑选一个节点（甚至每次请求都在变），所有这些均是通过 [lua-resty-core](https://github.com/openresty/lua-resty-core) 库的 [ngx.balancer](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md) 完成。  该指令配置的 Lua 代码在单个下游请求中可能被调用多次，例如使用 [proxy_next_upstream](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream) 配置小节，这是 nginx 自身上游尝试请求机制。  这里 Lua 代码的执行环境不支持 yield 操作，所以可能 yield 的 Lua API （例如 cosockets 和 “轻线程”），在这个环境中是被禁用的。一个可以使用并绕过这个限制的玩法，是可以在更早的阶段处理，比如 [access_by_lua*](#access_by_lua))，并传递结果到环境的 [ngx.ctx](#ngxctx) 表。  该指令在 `v0.10.0` 版本首次引入。  [返回目录](#directives)  balancer_by_lua_file --------------------  **语法:** *balancer_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *upstream*  **阶段:** *content*  除了通过文件 `<path-to-lua-script-file>` 的内容指定 Lua 代码外，该指令与 [balancer_by_lua_block](#balancer_by_lua_block) 是等价的，该指令从 `v0.5.0rc32` 开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  当给定了一个相对路径如 `foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项 `-p PATH` 决定的 `server prefix`。  该指令在 `v0.10.0` 版本首次引入。  [返回目录](#directives)  lua_need_request_body ---------------------  **语法:** *lua_need_request_body &lt;on|off&gt;*  **默认:** *off*  **环境:** *http, server, location, location if*  **阶段:** *depends on usage*  在运行 rewrite/access/access_by_lua* 之前决定是否强制获取请求体数据。 Nginx 内部默认不读取客户端请求体，如果需要读取请求体数据，需要使用该指令设置为 `on` 或者在 Lua 代码中调用 [ngx.req.read_body](#ngxreqread_body) 函数。  为了读取请求体数据到 [$request_body](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body) 变量，[client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) 必须要与 [client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size) 有同样的大小。因为内容大小超过 [client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) 但是小于 [client_max_body_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size) 时， Nginx 将把缓冲内存数据存到一个磁盘的临时文件上，这将导致 [$request_body](http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body) 变量是一个空值。  如果当前 location 包含 [rewrite_by_lua*](#rewrite_by_lua) 指令，请求体将在 [rewrite_by_lua*](#rewrite_by_lua) 代码运行之前（还是在`rewrite`阶段）被读取。如果只有 [content_by_lua](#content_by_lua) 指令，请求体直到内容生成的 Lua 代码执行时才会读取（既，请求体在处理生成返回数据阶段才回被读取）。  无论如何都非常推荐，使用 [ngx.req.read_body](#ngxreqread_body) 和 [ngx.req.discard_body](#ngxreqdiscard_body) 函数，可以更好的控制请求体的读取过程。  这个规则也适用于 [access_by_lua*](#access_by_lua) 。  [返回目录](#directives)  ssl_certificate_by_lua_block ----------------------------  **语法:** *ssl_certificate_by_lua_block { lua-script }*  **环境:** *server*  **阶段:** *right-before-SSL-handshake*  当 Nginx 开始对下游进行 SSL（https） 握手连接时，该指令执行用户 Lua 代码。  特别是基于每个请求，设置 SSL 证书链与相应的私有密钥，这种情况特别有用。通过非阻塞 IO 操作，从远程（例如，使用 [cosocket](#ngxsockettcp) API）加载 SSL 握手配置也是很有用的。并且在每请求中使用纯 Lua 完成 OCSP stapling 处理也是可以的。  另一个典型应用场景是在当前环境中非阻塞的方式完成 SSL 握手信号控制，例如在 [lua-resty-limit-traffic](https://github.com/openresty/lua-resty-limit-traffic) 库的辅助下。  我们也可以针对来自客户端的 SSL 握手请求做一些有趣的处理，比如可以有选择地拒绝使用了 SSL v3 甚至更低版本协议的老客户端。  [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md) 和 [ngx.ocsp](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md) Lua 模块是由 [lua-resty-core](https://github.com/openresty/lua-resty-core/#readme) 库提供，并且在该环境中特别有用。你可以使用这两个模块提供的 Lua API，处理当前 SSL 连接初始化的 SSL 证书链和私有密钥。  不管怎样，对于当前 SSL 连接，在 Nginx/OpenSSL 通过 SSL session IDs 或 TLS session tickets 成功唤醒之前，该 Lua 是不会运行的。换句话说，这个 Lua 只有当 Nginx 已经发起了完整的 SSL 握手才执行。  下面是个简陋的与 [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md) 模块一起使用的例子：  ```nginx   server {      listen 443 ssl;      server_name   test.com;       ssl_certificate_by_lua_block {          print("About to initiate a new SSL handshake!")      }       location / {          root html;      }  } ```  更多信息，可以参考 [ngx.ssl](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md) 的更多复杂例子 和 [ngx.ocsp](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md) Lua 模块的官方文档。  在用户 Lua 代码中未捕获的 Lua 异常将立即终止当前 SSL 请求，就如同使用 `ngx.ERROR` 错误码调用 [ngx.exit](#ngxexit) 。  该环境下的 Lua 代码执行 *支持* yielding，所以可能 yield 的 Lua API 在这个环境中是启用的（例如 cosockets，sleeping，和 “轻线程”）。  注意，无论如何，你仍然需要配置 [ssl_certificate](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate) 和 [ssl_certificate_key](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key) 指令，尽管你将完全不再使用这个静态的证书和私有密钥。这是因为 Nginx 内核要求它们出现否则启动 Nginx 时你将看到下面错误：      nginx: [emerg] no ssl configured for the server  该指令需要能工作的 Nginx 补丁版本地址：  <http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html>  对于 OpenResty 1.9.7.2 （或更高）绑定的 Nginx 版本，已经默认打上了补丁。  此外，该指令需要至少 OpenSSL `1.0.2e` 版本才能工作。  该指令是在 `v0.10.0` 版本首次引入。  [返回目录](#directives)  ssl_certificate_by_lua_file ---------------------------  **语法:** *ssl_certificate_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *server*  **阶段:** *right-before-SSL-handshake*   除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [ssl_certificate_by_lua_block](#ssl_certificate_by_lua_block) 是等价的，该指令从`v0.5.0rc32`开始支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  当给定了一个相对路径如`foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项`-p PATH`决定的`server prefix`。  该指令是在 `v0.10.0` 版本首次引入。  [返回目录](#directives)  ssl_session_fetch_by_lua_block ------------------------------  **语法:** *ssl_session_fetch_by_lua_block { lua-script }*  **环境:** *http*  **阶段:** *right-before-SSL-handshake*  该指令执行的代码，根据当前下游的 SSL 握手请求中的会话 ID，查找并加载 SSL 会话（如果有）。  <!-- This directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. -->  由 [lua-resty-core](https://github.com/openresty/lua-resty-core#readme) Lua 模块库内置的 [ngx.ssl.session](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md) API，可以获取当前会话 ID 并加载一个已缓存的 SSL 缓存数据。  <!-- The Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the [ngx.ssl.session](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md) Lua module shipped with the [lua-resty-core](https://github.com/openresty/lua-resty-core#readme) library. -->  Lua API 可能会挂起，比如 [ngx.sleep](#ngxsleep) 和 [cosockets](#ngxsockettcp)， 在这个环境中是启用的。  该钩子可以与 [ssl_session_store_by_lua*](#ssl_session_store_by_lua_block) 一起使用，实现纯 Lua 的分布式缓存模型（例如基于 [cosocket](#ngxsockettcp) API）。 如果找到一个已缓存 SSL 会话，将会加载到当前 SSL 会话环境中，SSL 会话将立即启动恢复，绕过昂贵的完整 SSL 握手过程（这里有非常昂贵 CPU 计算代价）。  <!-- This hook, together with the [ssl_session_store_by_lua*](#ssl_session_store_by_lua_block) hook, can be used to implement distributed caching mechanisms in pure Lua (based on the [cosocket](#ngxsockettcp) API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time. -->  请注意，TLS 会话票证是非常不同的，当使用会话票证时它是客户端完成 SSL 会话状态缓存。 SSL 会话恢复是基于 TLS 会话票证自动完成，不需要该钩子参与（也不需要 [ssl_session_store_by_lua_block](#ssl_session_store_by_lua) 钩子）。 该钩子主要是给老版本或缺少 SSL 客户端能力（只能通过会话 ID 方式完成 SSL 会话）。  <!-- Please note that TLS session tickets are very different and it is the clients' responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the [ssl_session_store_by_lua_block](#ssl_session_store_by_lua) hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs. -->  当同时指定了 [ssl_certificate_by_lua*](#ssl_certificate_by_lua_block)，该钩子通常在 [ssl_certificate_by_lua*](#ssl_certificate_by_lua_block) 之前运行。 找到 SSL 会话并成功对当前 SSL 连接加载后， SSL 会话将会恢复，从而绕过 [ssl_certificate_by_lua*](#ssl_certificate_by_lua_block) 钩子。这种情况下，NGINX 也将直接绕过 [ssl_session_store_by_lua_block](#ssl_session_store_by_lua) 钩子，不需要了嘛。  借助现代网络浏览器，在本地是比较容易测试这个钩子的。你可以暂时把下面这行配置放到 https server 小节，禁用 TLS 回话票证。      ssl_session_tickets off;  但是在你把网站放到外网之前，不要忘记注释掉这行配置。  <!-- To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:      ssl_session_tickets off;  But do not forget to comment this line out before publishing your site to the world. -->  如果你使用 [OpenResty](https://openresty.org/) 1.11.2.1 或后续版本绑定的 [官方的预编译包](http://openresty.org/en/linux-packages.html) ，那么一切都应只欠东风。  如果你正在使用的不是 [OpenResty](https://openresty.org) 提供的 OpenSSL 库， 你需要对 OpenSSL 1.0.2h 或后续版本打个补丁：  <https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch>  如果你没有使用 [OpenResty](https://openresty.org) 1.11.2.1 或后续版本绑定的 Nginx ， 那么你需要对标准 Nginx 1.11.2 或后续版本打个补丁：  <http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch>  该小节在 `v0.10.6` 首次引入。  请注意: 从 `v0.10.7` 版本开始，该指令只允许在 **http context** 环境中使用（因为 SSL 会话唤醒发生在服务名生效之前）。  [返回目录](#directives)  ssl_session_fetch_by_lua_file -----------------------------  **语法:** *ssl_session_fetch_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http*  **阶段:** *right-before-SSL-handshake*  除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [ssl_session_fetch_by_lua_block](#ssl_session_fetch_by_lua_block) 是等价的，该指令支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。  当给定了一个相对路径如 `foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项 `-p PATH` 决定的 `server prefix` 。  该指令在 `v0.10.6` 版本首次引入。  请注意: 从 `v0.10.7` 版本开始，该指令只允许在 **http context** 环境中使用（因为 SSL 会话唤醒发生在服务名生效之前）。  [返回目录](#directives)  ssl_session_store_by_lua_block ------------------------------  **语法:** *ssl_session_store_by_lua_block { lua-script }*  **环境:** *http*  **阶段:** *right-after-SSL-handshake*  该指令执行的代码，根据当前下游的 SSL 握手请求中的会话 ID，获取并保存 SSL 会话（如果有）。  This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.  被保存或缓存的 SSL 会话数据能被用到将来的 SSL 连接，恢复 SSL 会话却不需要历经完整 SSL 握手过程（这里有非常昂贵 CPU 计算代价）。  The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).  Lua API 可能会挂起，比如 [ngx.sleep](#ngxsleep) 和 [cosockets](#ngxsockettcp)， 在这个环境中被 *禁用* 了。尽管如此，你仍然可以通过 [ngx.timer.at](#ngxtimerat) API 来创建一个零延迟的 timer 用来异步方式保存 SSL 会话数据到外部服务中（比如 `redis` 或 `memcached`）。  由 [lua-resty-core](https://github.com/openresty/lua-resty-core#readme) Lua 模块库提供的 [ngx.ssl.session](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md) API，可以获取当前会话 ID 并关联到会话状态数据。  借助现代网络浏览器，在本地是比较容易测试这个钩子的。你可以暂时把下面这行配置放到 https server 小节，禁用 TLS 回话票证。      ssl_session_tickets off;  但是在你把网站放到外网之前，不要忘记注释掉这行配置。  <!-- To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:      ssl_session_tickets off;  But do not forget to comment this line out before publishing your site to the world. -->  该指令在 `v0.10.6` 版本首次引入。  请注意: 从 `v0.10.7` 版本开始，该指令只允许在 **http context** 环境中使用（因为 SSL 会话唤醒发生在服务名生效之前）。  [返回目录](#directives)  ssl_session_store_by_lua_file -----------------------------  **语法:** *ssl_session_store_by_lua_file &lt;path-to-lua-script-file&gt;*  **环境:** *http*  **阶段:** *right-before-SSL-handshake*   除了通过文件`<path-to-lua-script-file>`的内容指定 Lua 代码外，该指令与 [ssl_session_store_by_lua_block](#ssl_session_store_by_lua_block) 是等价的，该指令支持 [Lua/LuaJIT 字节码](#lualuajit-bytecode-support) 的执行。   当给定了一个相对路径如 `foo/bar.lua`，它将会被转换成绝对路径，前面增加的部分路径是 Nginx 服务启动时通过命令行选项 `-p PATH` 决定的 `server prefix` 。  该指令在 `v0.10.6` 版本首次引入。  请注意: 从 `v0.10.7` 版本开始，该指令只允许在 **http context** 环境中使用（因为 SSL 会话唤醒发生在服务名生效之前）。  [返回目录](#directives)   lua_shared_dict ---------------  **语法:** *lua_shared_dict &lt;name&gt; &lt;size&gt;*  **默认:** *no*  **环境:** *http*  **阶段:** *depends on usage*  声明一个共享内存区块 `<name>`，用来存储基于共享内存的 Lua 字典 `ngx.shared.<name>`。  在当前 Nginx 服务器实例中，共享内存区块被所有 nginx worker 进程共享。  `<size>` 参数可以通过类似 `k` 和 `m` 的大小单位来设置。  ```nginx   http {      lua_shared_dict dogs 10m;      ...  } ```  硬编码限制最小大小是 8KB，而实际的最小大小取决于实际中用户数据集（有些人是从 12KB 开始）。  更多细节请参考 [ngx.shared.DICT](#ngxshareddict)。  这个指令最早出现在版本 `v0.3.1rc22` 中。  [返回目录](#directives)  lua_socket_connect_timeout --------------------------  **语法:** *lua_socket_connect_timeout &lt;time&gt;*  **默认:** *lua_socket_connect_timeout 60s*  **环境:** *http, server, location*  该指令控制 TCP/unix-domain socket 对象的 [connect](#tcpsockconnect) 方法默认超时时间，这个值可以被 [settimeout](#tcpsocksettimeout) 或 [settimeouts](#tcpsocksettimeouts) 方法覆盖。  `<time>`参数可以是整数，后面可以跟着像`s` (秒), `ms` (毫秒), `m` (分钟)的单位可选项。 默认的时间单位是`s`，也就是"秒"。默认值是`60s`。  这个指令最早出现在版本 `v0.5.0rc1` 中。  [返回目录](#directives)  lua_socket_send_timeout -----------------------  **语法:** *lua_socket_send_timeout &lt;time&gt;*  **默认:** *lua_socket_send_timeout 60s*  **环境:** *http, server, location*  该指令控制 TCP/unix-domain socket 对象的 [send](#tcpsocksend) 方法默认超时时间，这个值可以被 [settimeout](#tcpsocksettimeout) 或 [settimeouts](#tcpsocksettimeouts) 方法覆盖。  `<time>`参数可以是整数，后面可以跟着像`s` (秒), `ms` (毫秒), `m` (分钟)的单位可选项。 默认的时间单位是`s`，也就是"秒"。默认值是`60s`。  该指令是在`v0.5.0rc1`版本第一次引入。  [返回目录](#directives)  lua_socket_send_lowat ---------------------  **语法:** *lua_socket_send_lowat &lt;size&gt;*  **默认:** *lua_socket_send_lowat 0*  **环境:** *http, server, location*  控制 cosocket 发送缓冲区 `lowat`（低水位）的值。  [返回目录](#directives)  lua_socket_read_timeout -----------------------  **语法:** *lua_socket_read_timeout &lt;time&gt;*  **默认:** *lua_socket_read_timeout 60s*  **环境:** *http, server, location*  **阶段:** *依赖于使用环境*  该指令控制 TCP/unix-domain socket 对象的 [receive](#tcpsockreceive) 方法、[receiveuntil](#tcpsockreceiveuntil) 方法返回迭代函数的默认超时时间。这个值可以被 [settimeout](#tcpsocksettimeout) 或 [settimeouts](#tcpsocksettimeouts) 方法覆盖。  `<time>`参数可以是整数，后面可以跟着像`s` (秒), `ms` (毫秒), `m` (分钟)的单位可选项。 默认的时间单位是`s`，也就是"秒"。默认值是`60s`。  该指令是在`v0.5.0rc1`版本第一次引入。  [返回目录](#directives)  lua_socket_buffer_size ----------------------  **语法:** *lua_socket_buffer_size &lt;size&gt;*  **默认:** *lua_socket_buffer_size 4k/8k*  **环境:** *http, server, location*  指定使用 cosocket 进行读取操作时的缓冲区大小。  这个缓冲区不必为了同时解决所有事情而设置的太大，因为 cosocket 支持 100 的非缓存读取和解析。所以即使是`1`字节的缓冲区大小依旧可以在任何地方正常工作，只不过效率比较糟糕。  该指令是在`v0.5.0rc1`版本首次引入。  [返回目录](#directives)  lua_socket_pool_size --------------------  **语法:** *lua_socket_pool_size &lt;size&gt;*  **默认:** *lua_socket_pool_size 30*  **环境:** *http, server, location*  指定每个 cosocket 通过远程服务(例如，使用主机+端口配对或 unix socket 文件路径作为标识)关联的连接池的大小限制（每个地址中的连接数）。  每个连接池默认是 30 个连接。  当连接池中连接数超过限制大小，在连接池中最近最少使用的（空闲）连接将被关闭，给当前连接腾挪空间。  注意，cosocket 连接池是每个 Nginx 工作进程使用的，而不是每个 Nginx 服务实例，所以这里指定的限制也只能在每个独立的 nginx 工作进程上生效。  该指令在`v0.5.0rc1`版本首次引入。  [返回目录](#directives)  lua_socket_keepalive_timeout ----------------------------  **语法:** *lua_socket_keepalive_timeout &lt;time&gt;*  **默认:** *lua_socket_keepalive_timeout 60s*  **环境:** *http, server, location*  该指令控制在 cosocket 连接池中连接的默认最大空闲时间。当这个时间到达，空闲的连接将被关闭并从连接池中移除。这个值可以使用 cosocket 对象的 [setkeepalive](#tcpsocksetkeepalive) 方法覆盖。  `<time>`参数可以是整数，后面可以跟着像`s` (秒), `ms` (毫秒), `m` (分钟)的单位可选项。 默认的时间单位是`s`，也就是"秒"。默认值是`60s`。  这个指令最早出现在版本 `v0.5.0rc1` 。  [返回目录](#directives)  lua_socket_log_errors ---------------------  **语法:** *lua_socket_log_errors on|off*  **默认:** *lua_socket_log_errors on*  **环境:** *http, server, location*  当 TCP 或 UDP cosockets 出现失败时，该指令可被用来切换错误日志输出。如果你已经正确处理了你的 Lua 代码错误日志，这里就推荐设置当前指令的开关为 off ，防止数据刷写到你的 nginx 错误日志文件（通常这个代价是比较昂贵的）。  这个指令最早出现在版本 `v0.5.13` 中。  [返回目录](#directives)  lua_ssl_ciphers ---------------  **语法:** *lua_ssl_ciphers &lt;ciphers&gt;*  **默认:** *lua_ssl_ciphers DEFAULT*  **环境:** *http, server, location*  指定在 [tcpsock:sslhandshake](#tcpsocksslhandshake) 方法中请求 SSL/TLS 服务 的加密方式。 其中参数 ciphers 是 OpenSSL 库里面指定的格式。  可以使用 “openssl ciphers” 来查看完整的加密方式列表。  该指令是在`v0.9.11`版本首次引入的。  [返回目录](#directives)  lua_ssl_crl -----------  **语法:** *lua_ssl_crl &lt;file&gt;*  **默认:** *no*  **环境:** *http, server, location*  指定一个 PEM 格式吊销证书文件，在 [tcpsock:sslhandshake](#tcpsocksslhandshake) 方法里验证 SSL/TLS 服务的证书。  该指令是在`v0.9.11`版本首次引入的。  [返回目录](#directives)  lua_ssl_protocols -----------------  **语法:** *lua_ssl_protocols \[SSLv2\] \[SSLv3\] \[TLSv1\] [TLSv1.1] [TLSv1.2]*  **默认:** *lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*  **环境:** *http, server, location*  在 [tcpsock:sslhandshake](#tcpsocksslhandshake) 方法中开启请求 SSL/TLS 服务的传输协议列表。  该指令是在`v0.9.11`版本首次引入的。  [返回目录](#directives)  lua_ssl_trusted_certificate ---------------------------  **语法:** *lua_ssl_trusted_certificate &lt;file&gt;*  **默认:** *no*  **环境:** *http, server, location*  指定一个 PEM 格式信任 CA 证书文件，在 [tcpsock:sslhandshake](#tcpsocksslhandshake) 方法里验证 SSL/TLS 服务的证书。  该指令是在`v0.9.11`版本首次引入的。  也可以看看 [lua_ssl_verify_depth](#lua_ssl_verify_depth).  [返回目录](#directives)  lua_ssl_verify_depth --------------------  **语法:** *lua_ssl_verify_depth &lt;number&gt;*  **默认:** *lua_ssl_verify_depth 1*  **环境:** *http, server, location*  设置服务端证书链的验证深度。  该指令是在`v0.9.11`版本首次引入的。  也可以看看 [lua_ssl_trusted_certificate](#lua_ssl_trusted_certificate)。  [返回目录](#directives)  lua_http10_buffering --------------------  **语法:** *lua_http10_buffering on|off*  **默认:** *lua_http10_buffering on*  **环境:** *http, server, location, location-if*  对 HTTP 1.0（或更老）请求，启用或禁用自动应答缓冲区。这个缓冲机制主要用于应答头包含合适`Content-Length`长度的 HTTP 1.0 长连接。  如果 Lua 代码在发送应答头之前明确设置了应答头的`Content-Length`（调用 [ngx.send_headers](#ngxsend_headers) 或 隐式首次调用 [ngx.say](#ngxsay) 或 [ngx.print](#ngxprint) 其中任何一个），HTTP 1.0应答缓冲区都将被禁用，即使这个指令是打开的。  流式输出（例如，调用 [ngx.flush](#ngxflush)）非常大的应答体，为了占用内存最小，该指令必须设置为`off`。  该指令默认值是`on`。  该指令是在`v0.5.0rc19`版本首次引入的。  [返回目录](#directives)  rewrite_by_lua_no_postpone --------------------------  **语法:** *rewrite_by_lua_no_postpone on|off*  **默认:** *rewrite_by_lua_no_postpone off*  **环境:** *http*  控制是否禁用 [rewrite_by_lua*](#rewrite_by_lua) 指令在`rewrite`阶段的延迟执行。该指令的默认值是 `off` ，在`rewrite`阶段的 Lua 代码将被延迟到最后执行。  该指令是在`v0.5.0rc29`版本首次引入的。  [返回目录](#directives)  access_by_lua_no_postpone -------------------------  **语法:** *access_by_lua_no_postpone on|off*  **默认:** *access_by_lua_no_postpone off*  **环境:** *http*  控制是否禁用 [access_by_lua*](#access_by_lua) 指令在 `access` 请求处理阶段末尾的推迟执行。默认的，该指令是 `off` 并且 `access` 阶段的 Lua 代码是被延迟到末尾执行。  该指令在 `v0.9.20` 版本首次引入。  [返回目录](#directives)  lua_transform_underscores_in_response_headers ---------------------------------------------  **语法:** *lua_transform_underscores_in_response_headers on|off*  **默认:** *lua_transform_underscores_in_response_headers on*  **环境:** *http, server, location, location-if*  对于 [ngx.header.HEADER](#ngxheaderheader) API 中指定响应头，该指令指定是否将下划线(`_`)转化为连接线(`-`)。  该指令是在`v0.5.0rc32`版本首次引入的。  [返回目录](#directives)  lua_check_client_abort ----------------------  **语法:** *lua_check_client_abort on|off*  **默认:** *lua_check_client_abort off*  **环境:** *http, server, location, location-if*  该指令控制是否探测客户端连接的过早终止。  当启用该指令，ngx_lua 模块将会在下游连接上监控连接过早关闭事件。当有这样的事件时，它将调用用户指定 Lua 的回调函数（通过 [ngx.on_abort](#ngxon_abort) 注册），当这里没有用户回调函数注册时，将停止当前请求并清理所有当前请求中运行的 Lua "轻线程" 。  根据目前实现，无论如何，如果请求正在通过 [ngx.req.socket](#ngxreqsocket) 读取请求体，在它之前客户连接发生关闭，ngx_lua 将不会停止任何正在执行的“轻线程”也不会调用用户的回调（尽管已经调用 [ngx.on_abort](#ngxon_abort) ）。作为替代，使用 [ngx.req.socket](#ngxreqsocket) 的读操作第二个参数将直接返回错误信息 “client aborted” 作为返回值（第一个返回值确定是`nil`）。  当 TCP 长连接被禁用，它依靠客户端 socket 关闭的优雅实现（通过发送一个`FIN`包或类似的东西）。  对与（软）实时 Web 应用，强烈推荐使用系统 TCP 协议栈支持的选项对 [TCP keepalive](http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html) 进行配置，以便及时发现“半开” TCP 连接。  例如，在 Linux，在你的`nginx.conf`文件中你能使用标准 [listen](http://nginx.org/en/docs/http/ngx_http_core_module.html#listen) 指令配置，像这样：  ```nginx   listen 80 so_keepalive=2s:2s:8; ```  对于 FreeBSD，你可以只调整 TCP 长连接的系统范围的配置，例如：      # sysctl net.inet.tcp.keepintvl=2000     # sysctl net.inet.tcp.keepidle=2000  该指令是在`v0.7.4`版本首次引入的。  也可以看看 [ngx.on_abort](#ngxon_abort) 。  [返回目录](#directives)  lua_max_pending_timers ----------------------  **语法:** *lua_max_pending_timers &lt;count&gt;*  **默认:** *lua_max_pending_timers 1024*  **环境:** *http*  控制允许使用的`pending timers`最大数量。  `pending timers` 指的是还没有过期的 `timers` 。  当超过这个限制， [ngx.timer.at](#ngxtimerat) 调用将立即返回 `nil` 和 错误信息 “too many pending timers”。  该指令是在`v0.8.0`版本首次引入的。  [返回目录](#directives)  lua_max_running_timers ----------------------  **语法:** *lua_max_running_timers &lt;count&gt;*  **默认:** *lua_max_running_timers 256*  **环境:** *http*  控制允许的`running timers`最大数量。  `running timers` 指的是那些正在执行用户回调函数的 timers 。  当超过这个限制，Nginx 将停止执行新近过期的 timers 回调，并记录一个错误日志 “N lua_max_running_timers are not enough”，这里的 "N" 是这个指令的当前值。  该指令是在`v0.8.0`版本首次引入的。  [返回目录](#directives)    
